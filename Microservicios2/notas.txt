Microservicios

Caracteristicas
-Funcion única
-Independientes
-Registro y auto-descubrimiento de servicios
-Auto escalable y agilidad, escalable segun demanda
-Confiabilidad y tolerancia a fallos, caminos alternativos en caso de falla
-Balanceo de cargas, cuando hay varias instancias (Ribbon)
-Configuración centralizada, mucha configuración en forma independiente por ello hay que centralizarla (Spring Cloud Config) 

Ventajas
-Innovación: la posibilidad adoptar nuevas tecnologias (lenguajes, frameworks, etc.) y procesos
-Reducción de costo: debido al autoescalamiento dinámico, solo se usa lo que se requiere durante el tiempo que se lo necesite
-Ciclos de liberación más rápidos: ya que se desarrollan componentes más pequeños
-Equipos de desarrollo más pequeños, más especializado.

Nombre del microservicio
En application properties establecemos un nombre, un identificador, para que el Eureka Server pueda acceder a este recurso mediante el y no através de su ubicación, de la IP ni del puerto. Este nombre también se utiliza en el balanceo de cargas.

spring.application.name=servicio-productos
server.port=8081

RestTemplate
Es un cliente para trabajar con API REST. Es un cliente HTTP para poder acceder a recursos que están en otros micro servicios.

Streams
Las listas tienen el metodo stream. Convierte la lista en un flujo.
Con map podemos cambiar cada elemento, se le pasara como argumento una expresión lambda.

TECNOLOGIA: FEIGN
Simple. Utiliza interfaces y notaciones declarativas.
Se integra con el balanceo de carga de Ribbon.
Viene configurado en los clientes de Eureka.

@EnableFeignClients -> notacion que va en Application.
@FeignClient(name="nombre del micro servicio al cual nos queremos conectar") -> notacion con la cual se define un cliente.

Los Mapping en los controller los usamos para mappear nuestros metodos handdler a endpoint a rutas url. Mientras, en el Feign  Client, indicamos la ruta end point para condumir el servicio. 

TECNOLOGIA: RIBBON
Para balanceo de cargas.
Se puede desacoplar el cliente de FEIGN con el puerto. Aunque en este punto siguen existiendo, ya no estan en el codigo los puertos, si no que se encuentran en los properties.
Se va a tener más de una instancia con la cual nos queremos comunicar, en estos casos Ribbon ayudara a decidir cual instancia es la mejor opción en un determinado momento.

@RibbonClient vs @RibbonClients
Cuando tenemos más de una clase cliente feign anotada con @FeignClient se usa en plural.

application.properties
nombre-del-servicio-a-conectar.ribbon.listOfServer=localhost:8081, localhost:9001

Para utilizar el balanceo de cargas de Ribbon con RestTemplate se utiliza la notacion: @LoadBalanced en la clase de configuracion, en el cliente que levantamos con @Bean.

TECNOLOGIA: EUREKA
Los clientes cuando se despliegan se comunican con Eureka Server y van a registarse con el nombre de la maquina o la IP, y el puerto. Como respuesta Eureka Server, una vez que estan registrados, va a pasar el registro completo a los demás microservicios que estan registrados en este ecosistema, de tal forma que puedan comunicarse y escalar forma independiente sin especificar ni puerto, nombre de dominio, IP, etc.

Eureka se registra como cliente y como servidor. Si queremos implementar alguna funcionalidad dejamos el por defecto, pero si no, seteamos en properties el cliente como false, asi como tambien su fetch.

Si se utiliza JDK 9 en adelante se debe agregar una dependencia en el pom: JAXB.

La buscamos en la ultima version estable de spring cloud 
-> Reference Doc.
verificacmos hasta que version spring boot suporta y modificamos en el pom: 
	->Supported Boot Version: 2.4.3
->spring-cloud-netflix
->Service Discovery: Eureka Server
->JDK 11 Support

https://docs.spring.io/spring-cloud-netflix/docs/3.0.2/reference/html/

<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
</dependency>


Y habilitamos en EurekaServerApplication el server con la notacion:
@EnableEurekaServer

Para habilitar clientes:
Agregamos la dependencia para clientes.
<dependency>
	<groupId>org.glassfish.jaxb</groupId>
	<artifactId>jaxb-runtime</artifactId>
</dependency>

y agregar:
<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>Greenwich.SR1</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>

y habilitamos el cliente en el Application con la notacion:
@EnableEurekaClient

En applicacion.properties podemos especificar cual es nuestro servidor de eureka, aunque es opcional siempre y cuando el eureka server este en el mismo servidor que los clientes. Si estan en distintas maquinas, es obligatorio especificar su ubicacion fisica: nombre de dominio o la maquina y el puerto. 

eureka.client.service-url.defaultZone=http://localhost:8761/eureka

Necesitamos su ubicacion para que cuando los clientes intenten comunicarse con el mandando un heartbeat este les comunique su habilitacion.

	INVESTIGAR : HEARTBEAT
	Los microservicios se registran de forma automatica mandando una señal.
	Luego, cada 30 segundos, mandan una nueva para actualizar.
	Si pasan más de 3 periodos sin mandar señal, el registro del 	microservicio se elimina.
	Si vuelve ha querer registrarse, luego de haber sido eliminado, necesitara enviar 3 señales (90 segundos) para que quedo habilitado 	nuevamente en el servidor de eureka.

Eureka tiene incluido Ribbon asi que no hace falta agregar la dependency y otras configuraciones (por ej. ombre-del-servicio-a-conectar.ribbon.listOfServer=localhost)de Ribbon si tenemos la de eureka.

Con esto desacoplamos completamente la ubicacion fisica, queda totalmente abstraido.

ESCALAR MICROSERVICIOS CON PUERTO DINAMICO
Para no escribir de forma explicita el puerto en application.properties lo automatizamos:
server.port=${PORT:0}
Con esto se asigna a un valor random, lo asigna la aplicacion a un puerto que este disponible.

Configurar la instancia en Eureka:
eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}

Esta configuracion es utilizada en los microservicios que vamos a querer escalar, donde vamos a tener varias instancias y vamos a tener que hacer un balanceo de carga.

	RECORDAR: que para ejecutar las instancias hay que sacar los "vmArgs" 	del launch.json

HERRAMIENTA HYSTRIX
Herramienta que permite manejar errores en microservicios. Gestiona la comunicacion entre los servicios y añade la logica de tolerancia de fallos, latencia, timeout, etc. 

Funciona con un limite de errores, pasado ese limite ya no deriva mas peticiones a ese micro servicio o a esa instancia. Permite, ademas, tener un camino alternativo, implementar logicas por defecto en caso de error, para evitar errores en cascada.
	
	PATRON: CIRCUIT BREAKER

Dependencias:
 -Hystrix
 -Hystrix Dashboard (para monitorear errores, los request exitosos, metricas de errores para poder analizar, detectar y solucionar los problemas de nuestro sistema)

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>

Para habilitarlo:
Tenemos que agregar la notacion en la Application:
@EnableCircuitBreaker -> funciona hasta la 2.3.4 -> @EnableHystrix ya no es parte de spring cloud

Para hacer caminos alternativos en caso de falla se usa:
@HystrixCommand(fallbackMethod = "alternativeMethod")
sobre el metodo que se quiere asegurar.
Luego se escribe un metodo con el nombre provisto que sea similar al cual no pudo ejecutarse (mismos argumentos y retorno).
Este se activara cuando el primero falle.

HYSTRIX Y RIBBON
Para administrar pausas.
Para poder configurarlos hay que modificar ambos, por que los dos tienen sus propios Time outs.
Tener en cuenta que Hystrix envuelve a Ribbon y por lo tanto debe tener un tiempo de espera mayor que el de Ribbon.

->spring.io
->projects
->spring cloud netflix
->learn
->elegir ultima GA estable -> reference doc.
->router and filter: zuul
->uploading files through zuul

->se aplica al application.properties del servicio que se comunica con el cliente
-recordando que el tiempo de hystrix debe ser mayor que la suma de los de ribbon.
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000
ribbon.ConnectTimeout: 3000
ribbon.ReadTimeout: 60000

LIBRERIA ZUUL
Trabaja de forma automatica con Hystrix y Ribbon.
Se crea un proyecto micro servicio que se encarga del acceso al resto de los servicios que estan deplegados, publicados en el servidor de eureka.
La puerta de enlace.

-Caracteristica mas importante: Enrutamiento dinamico
Va a enrutar a cada uno de los mmicroservicios que esten registrados en el servidor de eureka.

-Se integra de forma automatica con Ribbon:
Todas las peticiones que realiza son atraves de balanceo de cargas.

-Tiene filtros
Por ejemplo:
 *) tiene un filtro apra dar seguridad a las rutas. En vez de configurar  en spring security en cada servicio de forma separada. Lo configuramos una sola vez en nuestra puerta de enlace.
*) tambien tiene filtros para monitorear distintas metricas.
*) manejar tolerancia de errores.

Con esto podemos acceder a nuestros servicios desde la puerta de enlace, desde zuul, con el enrutado dinámico. Ya no es necesario ingresar a cada microservicio por separado. Arquitectura que centraliza sus microservicios.

Tipos de filtros de Zuul:
1) PRE - Pre route : Antes que se resuelva la ruta. Se ejecuta antes de que el request sea enrutado hacia un microservicio. Se usa para pasar datos al request.
2) POST - Post route: Se ejecuta después de que el request haya sido enrutado. Se utiliza para manipular la respuesta.
3) ROUTE : Se ejecuta durante el enrutado del request, aquí se resuelve la ruta. Se usa para la comunicación con el microservicio. Se resuelve la ruta al microservicio y se resuelve la request al microservicio enrutado.
4) ERROR : Nos permite manejar y procesar errores.

Aplicacion de un Filtro:
EJ. Tiempo Trancurrido
->Se necesita un filtro pre y uno post. El pre para calcular el tiempo inicial antes del enrutamiento y el post que va a tomar el tiempo del pre y se lo va a restar al tiempo final, obteniendo el tiempo transcurrido en mili segundos.

->Es importante designar a las clases como @Component (como Bean de Spring) y extender de ZuulFilter. Estos dos pasos lo registran automaticamente como Filtro de Zuul.

->Al implementar los metodos de la clase ZuulFilter:
	1)En filterType devolvemos un String que indica el tipo de filtro. ("pre", "post", "route", "error")
	2)En Order devolvemos un int que representa el orden de ejecucion.
	3)En shouldFilter ejecutamos un alguna logica para determinar si ejecutamos el filtro o no, y devolvemos booleano.
	4) En run se ejecuta la logica del filtro propiamente dicha. 

Para manejar time outs: 
-> Agregamos en application.properties la configuracion de hystrix y ribbon.

SPRING CLOUD - CONFIG SERVER
Sirve para centralizar la configuración de todos los micro servicios, a fines de poder administrarla de manera más eficientes.

Por lo general, en una arquitectura de micro servicios, vamos a tener multiples micro servicios, con configuraciones y entornos o ambientes distintos. Esto puede general conflictos a la hora de realizar cambios.

Por defecto, esta configuracion centralizada, se guarda en un repositorio GIT, ya sea de forma local o remota. Pero, tambien, da la posibilidad de administrar los archivos de forma fisica en algun directorio de nuestro servidor sin la utilizacion de GIT.

Funcionamiento:
->Durante el arranque del micro servicio, primero, antes de registrarse en Eureka va a consultar al servidor de configuración todos sus atributos, propiedades de configuracion. Una vez que las obtiene del repositorio de GIT se va a registrat en Eureka y va a arrancar el micro servicio.

->Ejemplos de configuraciones personalizadas pueden abarcar: puerto, conexiones a base de datos, etc. Cada ambiente o Profile puede tener una configuracion distinta.

Notaciones:
@EnableConfigServer

Application Properties:
server.port=8888 (default)
spring.cloud.config.server.git.uri=

->Si vamos a configurar con repositorio local en Windows: file:///C:/...
->Si vamos a configurar con repositorio local en Linux: file:/C:/...

Tenemos que crear la carpeta e inicializarlo como repositorio de GIT.

Luego crear los archivos de configuracion desde la terminal: 
	-> ej: echo server.port=8005 > servicio-items.properties

NOTA: importante no dejar espacios en blanco.

La configuracion en el config server va a sobre escribir la application.properties de los microservicios. Si hay configuraciones que no existen se van a combinar las que existen en el servidor con la personalizada de cada micro servicio.

Al runearlo se:
->Escribe el puerto 
->El nombre del micro servicio
->El ambiente o profile (si no hay ninguno es:default)
->localhost:8888/servicio-items/default

Para modificar los microservicios, y que estos puedan acceder a las configuraciones del config server:
->Modificar dependencias-> Agregar Config Client
->Modificar application.properties->bootstrap.properties
->En bootstrap.properties-> 
	spring.application.name -> el nombre del mmicro servicio
	spring.cloud.config.uri -> la ruta del servidor de configuracion
	tambien se agrega aqui el profile.
->bootstrap tiene prioridad y todo lo que este escrito en application.properties no va a sobreescribir lo de bootstrap.

Configurar ambientes o profiles:
->Se agregan en el repositorio GIT
->Se escriben en formato nombreservicio-profile.properties
->Se agregan en el micro servicio en el bootstrap.properties como:
	spring.profiles.active=development

Como reflejar cambios en el repositorio local en tiempo real:
Como reflejar cambios en las configuraciones alamacenadas en nuestro repositorio GIT en tiempo real en nuestros micro servicios, sin tener que reiniciar la aplicacion.
Anteriormente los cambios que generabamos en la configuración no se veian reflejados inmediatamente en el microservicio, esto se debe al contexto, por que los controladores en donde se inyecta esta configuración son Singleton, por lo tanto, va a durar el cliclo de vida de este componente lo que dure la aplicación, con una sola instancia.
Un modo de actualizar este componente para que refresque esos cambios y se actualice es a través de @RefreshScope y Actuator:
Atrevés de un endpoint de Actuator nos permite refescar todos estos componentes que estan anotados con @RefreshScope.
->Controller ->Se agrega la notacion @RefreshScore -> esto permitira que las application.properties se actualicen automaticamente y, por ejemplo, los valores de @Value cambien sin tener que reiniciar la aplicacion.
-> Se agrega dependencia Actuator->
	<dependency>
        	<groupId>org.springframework.boot</groupId>
        	<artifactId>spring-boot-starter-actuator</artifactId>
    	</dependency>
->Se agrega en bootstrap.properties el endpoint de actuator->
	management.endpoints.web.exposure.include=*
	con el asterisco incluimos todos los endpoints de spring 	booot actuator.

Cuando se modifiquen propiedades se tendra que hacer un refresh desde el endpoint de actuator:
1) localhost:8086/actuator/refresh (8086 configurado en repositorio local)
2) tiene que ser como POST

Solo podemos cambiar configuracion propias, no asi el puerto, conexiones a base de datos, etc.

REPOSITORIO REMOTO
Para cambiar por un repositorio remoto en GIT cambiamos en config server la uri por la url del repositorio remoto terminado en .git

CRUD: Consumiento APIS con FEIGN Y REST TEMPLATE
->Repository -> save() -> si id es null crea el objeto, si el id no es null hace update.

¿Como consumir API mediante REST TEMPLATE?
->Agregar en la interfaz de service-item metodos para agregar, editar y eliminar
->Implementarlas en la implementacion de la interfaz

->SAVE()
->utilizar restTemplate.exchange(endpoint, metodo, request, clase)
->la request es una HTTPentity<clase>
->metodo: POST

->UPDATE()
->Map -> pathVariable -> id
->utilizar restTemplate.exchange(endpoint/{PathVariable}, metodo, request, clase, pathvariable)
->la request es una HTTPentity<clase>
->metodo: PUT

->DELETE()
->Map -> pathVariable -> id
->utilizar restTemplate.delete(endpoint/{PathVariable}, pathVariable)

->Implementar mappings en controller
->Cambiar qualifier a restTemplate

¿Como consumir API mediante FEIGN?
->Agregar en la interfaz de feignclient los metodos CRUD para consumir API REST
->Implementar CRUD en el service de Feign utilizando el cliente fiegn autowired.
->Cambiar qualifier en controlador -> clientFeign

SERVICIO COMMONS: REUTILIZAR LIBRERIAS
->proyecto nuevo con jpa y h2
->quitamos metodo main, por que es un proyecto de libreria no es un proyecto ejecutable
->quitamos del pom el plugin de maven
->realizar clases de entidad
->generar jar
->se necesita tener configurado la variable de entorno JAVA_HOME y PATH con la ubicacion del jdk y del jdk/bin respectivamente.
-> ejecutar en el directorio de commons el comando> mvnw.cmd install
-> disponible en el repositorio local de maven con lo cual puede agregarse como dependencia en el pom de los otros servicios

jpa exige configuracion de database, pero como es una libreria no nos hace falta la database, una opcion es agregar en el pom h2 por que se configura solo, pero si no queremos agregarlo podemos agregar la notacion EnableAutoConfiguration en la clase principal anotada con springbootaplication.

@EnableAutoConfiguration(exclude={DataSourceConfiguration.class})

Para agregar esta nueva dependencia en otros microservicio tenemos que ir al pom de la libreria y copiar:
	<groupId>ayi.microservicios</groupId>
	<artifactId>commons</artifactId>
	<version>0.0.1-SNAPSHOT</version>

Vamos al pom del microservicio en el cual queremos agregar la libreria y agregamos una nueva dependencia:
	<dependency>
		<groupId>ayi.microservicios</groupId>
		<artifactId>commons</artifactId>
		<version>0.0.1-SNAPSHOT</version>
	</dependency>

Luego hay que cambiar los import para que utilicen la libreria.
->utilizado en products.
->se puede eliminar el package de entidad

PROBLEMA: La clase de entidad Producto no esta en el mismo conectexto, esta en la libreria, por lo cual hay que configurar el proyecto servicio-producto para que lo detecte y reconozca a Producto.

->En la clase principal anotada con SpringBootApplication en el microservicio que consume la libreria utilizamos el EntityScan y proporcionamos la locación de las clases que vamos a utilizar:
	@EntityScan({"ayi.microservicios.commons.entity"})

SPRING CLOUD SECURITY
Autenticacion: se refiere al proceso de establecer un principal(un usuario, dispositivo o algun otro sistema el cual puede ejecutar alguna accion en nuestro sistema), en general permite a los principal autenticarse en base a cualquier proveedor de seguridad, ej: LDAP, Base de datos relacional, Autentificacion HTTP.

Autorizacion: Se refiere al proceso de decidir si se otorga acceso a un usuario para realizar una accion dentro de la aplicacion, es decir, para controlar el acceso a los recursos de la aplicacion por medio de la asignacion de roles y permisos a grupos de usuarios.

Recursos: Puede ser el backend, api rest, controladores, servicios, logica de negocios,etc.

Roles: Grupo o tipo de usuario al cual se le otorgan cierto tipos de privilegios para llevar a cabo una o varias acciones dentro de la aplicacion. Son construcciones simples, que constan de un nombre. Pueden consederse a un usuario o a otros roles.
Se utilizan para crear grupos logicos de usuarios para la asignacion adecuada de los privilegios en las aplicaciones.

JWT -> Json Web Token
Estandar abierto para implementar seguridad en nuestras aplicaciones API REST basado en Token. Estandar RFC 7519, una forma segura de representar reclamos entre dos partes (cliente-servidor).
Un usuario envia un codigo alfanumerico (no contiene información sensible) al servidor y el servidor se encarga de desifrar decodificar validar y determina si el usuario esta registrado en nuestro sistema y tiene el permiso a traves de sus roles. De acuerdo a esto le va a dar acceso o no a determinadas páginas, partes o recursos de nuestra aplicación.
Tambien se encarga de generar este codigo de una palabra, o codigo secreto que tengamos configurado en nuestro servidor. Este codigo secreto o certificado, solo se mantiene en el servidor, es privado y nunca un cliente va a poder obtener información de ella, ya que a través de este codigo se genera el json web token y tambien como se valida o verifica.
Esto nos permite evitar guardar sesiones en el servidor, como consecuencia nuestro servidor será más ligero.

Caracteristicas:
-Muy compacto
-Se puede enviar a traves de : peticion web, url o un parametro POST o dentro de la cabeceras HTTP en Authorization (recomendada).
-Transimision agil liviana
-Contiene toda la informacion necesaria, por lo cual no es necesario hacerle consultas al servidor constantemente
-No se necesita guardar sesiones en el servidor

Importante: Esta codificado en doble via, por lo tanto es reversible y se puede leer su información, se puede decodificar y, como cualquier persona con conocimiento suficiente puede leer y manipular esta informacion, no podemos pasar informacion sensible atraves de ella. 

Timpo:
-Si no se determina tiempo de caducidad es por tiempo indeterminado, pero es importante como buena practica determinar este tiempo de expiración.
-Mucho tiempo puede traducirse en problemas para eliminar usuarios debido a que los token aun son validos.
-Poco tiempo nos obliga a iniciar sesion a cada rato.
-Encontrar el tiempo adecuado: 1h-4h-etc.

Es STATELESS, no tiene estado, no mantiene una persistencia. Cada vez que queremos acceder a un recurso que esta protegido en el servidor tenemos que enviar el JTW.

Partes que conforman el JWB:
-3 partes separadas por puntos "."
-Header: Contiene informacion sobre el algoritmo en el cual se va a codificar los tokens, y tambien el tipo.
-Payload: Informacion del usuario. sup, representa un identificador, tipicamente es el nombre de usuario, un email, un numero unico, etc. La informacion que necesitemos. Las fechas de creacion y expiracion. Los roles. Etc.
-Verify Signature: es requerido un codigo secreto, que de acuerdo a ese codigo se generan los JWT y tambien se decodifica en funcion de este codigo. Una aplicacion cliente jamas va a tener acceso a este codigo. Sirve para saber que un toklen no fue manipulado.

Se guarda en el Session Storage o en el LocalStorage. F12 -> pestaña Application -> Session Storage o Local Storage. En el Session Storage la informacion permanece persistente mientras este activo el navegador, en cambio, Local Storage que de forma persistente en el equipo aun si el navegador se cierra. Ambos comparten su informacion atraves del dominio. Cuando se eligen tiempos mas extensos de expiracion lo mejor es guardar esa informacion en Local Storage. En cambio cuando es un par de horas se utiliza el Session Storage. 

Ninguno es mas seguro que el otro.

OAUTH2
Es un framework, un protocolo estandar de autorizacion que permite a las aplicaciones de terceros autenticarse con una cuenta de usuario ubicada en otra aplicacion, en un servicio HTTP externo. Para compartir un sistema de autenticacion de una aplicacion a otra, sin compartir toda la informacion del usuario ni las credenciales.

Se compone de 2 partes:
-El servidor de autorizacion (Authorization Server): se encarga de realizar la autenticacion del usuario y, si se valida, genera un token que es proveido al usuario para que pueda acceder a los distintos recursos de nuestra aplicacion.
-El servidor de recursos (Resource Server): se encarga de administrar los permisos y accesos hacia nuestros endpoints que estan con seguridad. Por debajo, el resource server aplica un filtro de Spring o OAuth2 Authentication Processing Filter, el cual se utiliza para validar y dar acceso a una peticion HTTP o Reuqest que viene desde el cliente.Este request es el que envia el token de acceso en las cabeceras y si es valido el servidor de recurso otorga el permiso para que el cliente pueda acceder a los recursos del backend.

Proceso del Authorization Server:
-Ruta url, del tipo POST, Auth Token. Esta ruta es proveida por Spring y nos permite realizar el login, autenticacion. Si este proceso de autenticacion es correcto, genera el token.
-En la ruta Auth Token se envian parametros. Principal: Authorization(client_id:client_secret) concatenados con ":" y encriptado en base64. Es una autorizacion del tipo Basic. Ademas se manda el Content-Type, del tipo form-urlencoded.
-En el cuerpo del request: las credenciales que son el username y el password, y el grant_type del tipo password. 
-Cuando el usuario ya tiene el token se mandara la ruta del tipo GET para consumir un recurso, y en la cabecera se envia el atributo Authorization del tipo Bearer y el token de acceso.
-Si el usuario tiene la autorizacion correspondiente se le retornara el recurso que esta pidiendo.

NOTA: utilizar LAZY por que nos va a traer solo la consulta que buscamos, y es recomendada esta practica. Cuando tenemos una base de datos grande y muchas relaciones utilizar EAGER significaria traer toda la base de datos. Utilizar LAZY nos evita una sobre carga en el performance, por que solo cuando utilicemos el GET se va a hacer la consulta en la base de datos mediante el proxy.

REST REPOSITORIES
Otra forma de implemenrar CRUDS de forma automatica.

	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-rest</artifactId>
	</dependency>

@RepositoryRestResource(path = "usuarios")
Se utiliza en el repositorio y generera todo el CRUD de manera automatizada.

Con eso nos va a devolver un JSON con estructura segun el estandar HATEOAS (Hypermedia as the Engine of Application State). Es una restricción de la lectura del API REST. Cuando el servidor retorna el JSON tambien devuelve informacion en forma de hipervinculos y otros recursos del API, que le indica al cliente como navegar, como encontrar la informacion. El cliente no requiere ningun conocimiento previo acerca de la forma de interactuar con la aplicacion, con el API REST, este estandar proporciona enlaces que son como una documentacion de como tenemos que navegar la aplicacion.

Para acceder a los mas comunes con poner PUT, POST, DELETE, GET y enviar el parametro o el JSON basta.
Para los personalizados: localhost:8097/api/usuarios/usuarios/search/findByUsername?username=Vanessa04
En caso de que queramos renombrar, tanto path como parametro:
	@RestResource(path="/buscar-username")
    	public Usuario findByUsername(@Param("usuario") String username);

	localhost:8097/api/usuarios/usuarios/search/buscar-username?usuario=Maria123

Configurar JSON para mostrar cierta informacion:

@Configuration
public class RepositoryConfig implements RepositoryRestConfigurer{
    
    @Override
    public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config){
        config.exposeIdsFor(Usuario.class, Role.class);
    }
}


